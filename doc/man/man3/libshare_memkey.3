.TH "Utility functions to generate unique checksums of data." 3 "11 Apr 2013" "Version 2.0.5" "libshare" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Utility functions to generate unique checksums of data. \- 
.PP
Key token generator.  

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBshkey_t\fP"
.br
.RI "\fIA key used to represent a hash code of an object. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBshkey_bin_r\fP(_bindata, _binlen, _key)"
.br
.RI "\fIGenerates a 64-bit key based on the data segment's checksum based on major and minor variants. \fP"
.ti -1c
.RI "#define \fBSHKEY_WORDS\fP   4"
.br
.RI "\fIThe number of 'word size' segments the key code is composed of. \fP"
.ti -1c
.RI "#define \fBashkey_blank\fP()   ((\fBshkey_t\fP *)_shkey_blank)"
.br
.RI "\fIGenerates a blank \fBshkey_t\fP key token. \fP"
.ti -1c
.RI "#define \fBshkey_is_blank\fP(_key)   (0 == memcmp((_key), (uint32_t *)_shkey_blank, sizeof(uint32_t) * 4))"
.br
.RI "\fIDetermines whether a \fBshkey_t\fP has been initialized. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBshkey_t\fP \fBshkey_t\fP"
.br
.RI "\fIA key used to represent a hash code of an object. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBshkey_t\fP * \fBshkey_bin\fP (char *data, size_t data_len)"
.br
.RI "\fICreate a \fBshkey_t\fP hashmap key reference from a binary memory segment. \fP"
.ti -1c
.RI "\fBshkey_t\fP * \fBshkey_str\fP (char *kvalue)"
.br
.RI "\fICreate a \fC\fBshkey_t\fP\fP hashmap key reference from \fCkvalue\fP \fIkvalue\fP The string to generate into a \fC\fBshkey_t\fP\fP. \fP"
.ti -1c
.RI "\fBshkey_t\fP * \fBshkey_num\fP (long kvalue)"
.br
.RI "\fICreate a \fC\fBshkey_t\fP\fP hashmap key reference from a number. \fP"
.ti -1c
.RI "\fBshkey_t\fP * \fBshkey_uniq\fP (void)"
.br
.RI "\fICreate a unique \fC\fBshkey_t\fP\fP hashmap key reference. \fP"
.ti -1c
.RI "void \fBshkey_free\fP (\fBshkey_t\fP **key_p)"
.br
.ti -1c
.RI "const char * \fBshkey_print\fP (\fBshkey_t\fP *key)"
.br
.RI "\fIA string hexadecimal representation of a \fC\fBshkey_t\fP\fP. \fP"
.ti -1c
.RI "\fBshkey_t\fP * \fBashkey_str\fP (char *name)"
.br
.RI "\fIGenerates a \fBshkey_t\fP from a string that does not need to be freed. \fP"
.ti -1c
.RI "\fBshkey_t\fP * \fBashkey_num\fP (long num)"
.br
.RI "\fIGenerates a \fBshkey_t\fP from a number that does not need to be freed. \fP"
.ti -1c
.RI "int \fBshkey_cmp\fP (\fBshkey_t\fP *key_1, \fBshkey_t\fP *key_2)"
.br
.RI "\fICompare two \fBshkek_t\fP key tokens. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Key token generator. 
.SH "Define Documentation"
.PP 
.SS "#define ashkey_blank()   ((\fBshkey_t\fP *)_shkey_blank)"
.PP
Generates a blank \fBshkey_t\fP key token. \fBReturns:\fP
.RS 4
A statically allocated blank key token. 
.RE
.PP
\fBNote:\fP
.RS 4
Do not free the returned value. 
.RE
.PP

.PP
Definition at line 138 of file shmem_key.h.
.SS "#define shkey_bin_r(_bindata, _binlen, _key)"\fBValue:\fP
.PP
.nf
(_key)->data_len = (_binlen); \
  (_key)->code[3] = (uint32_t)shcrc((_bindata), (_binlen)); \
  (_key)->code[0] = (uint32_t)shcrc((_bindata), (_binlen) / 4); \
  (_key)->code[1] = (uint32_t)shcrc((_bindata) + ((_binlen) / 3), (_binlen)/2); \
  (_key)->code[2] = (uint32_t)shcrc((_bindata), (_binlen) / 3);
.fi
.PP
Generates a 64-bit key based on the data segment's checksum based on major and minor variants. \fBParameters:\fP
.RS 4
\fI_data\fP The data segment to generate a key from. 
.br
\fI_data_len\fP The size of the data segment. 
.br
\fI_key\fP A pointer to the \fBshkey_t\fP to fill in. 
.RE
.PP

.PP
Definition at line 42 of file shmem_key.h.
.SS "#define shkey_is_blank(_key)   (0 == memcmp((_key), (uint32_t *)_shkey_blank, sizeof(uint32_t) * 4))"
.PP
Determines whether a \fBshkey_t\fP has been initialized. \fBReturns:\fP
.RS 4
FALSE is key is not blank, and TRUE is the key is blank. 
.RE
.PP
\fBNote:\fP
.RS 4
It is possible to generate keys which equal a blank key, for example a key generated from a zero-length data segment. This macro should be utilitized only when it is known that the key being compared against has a unique value. 
.RE
.PP

.PP
Definition at line 146 of file shmem_key.h.
.SS "#define SHKEY_WORDS   4"
.PP
The number of 'word size' segments the key code is composed of. 
.PP
Definition at line 57 of file shmem_key.h.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBshkey_t\fP \fBshkey_t\fP"
.PP
A key used to represent a hash code of an object. 
.PP
Definition at line 52 of file shmem_key.h.
.SH "Function Documentation"
.PP 
.SS "\fBshkey_t\fP* ashkey_num (long num)"
.PP
Generates a \fBshkey_t\fP from a number that does not need to be freed. \fBSee also:\fP
.RS 4
shkey_free() 
.RE
.PP
\fBBug\fP
.RS 4
psuedo thread-safe 
.RE
.PP

.SS "\fBshkey_t\fP* ashkey_str (char * name)"
.PP
Generates a \fBshkey_t\fP from a string that does not need to be freed. \fBSee also:\fP
.RS 4
shkey_free() 
.RE
.PP
\fBBug\fP
.RS 4
psuedo thread-safe 
.RE
.PP

.SS "\fBshkey_t\fP* shkey_bin (char * data, size_t data_len)"
.PP
Create a \fBshkey_t\fP hashmap key reference from a binary memory segment. 
.SS "int shkey_cmp (\fBshkey_t\fP * key_1, \fBshkey_t\fP * key_2)"
.PP
Compare two \fBshkek_t\fP key tokens. \fBReturns:\fP
.RS 4
A zero is both keys are identical and a -1 if the keys are unique. 
.RE
.PP

.SS "\fBshkey_t\fP* shkey_num (long kvalue)"
.PP
Create a \fC\fBshkey_t\fP\fP hashmap key reference from a number. \fIkvalue\fP The number to generate into a \fC\fBshkey_t\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A statically allocated version of  
.RE
.PP

.SS "const char* shkey_print (\fBshkey_t\fP * key)"
.PP
A string hexadecimal representation of a \fC\fBshkey_t\fP\fP. \fBNote:\fP
.RS 4
The string returned will be 32 characters long. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBshkey_t\fP 
.RE
.PP

.SS "\fBshkey_t\fP* shkey_str (char * kvalue)"
.PP
Create a \fC\fBshkey_t\fP\fP hashmap key reference from \fCkvalue\fP \fIkvalue\fP The string to generate into a \fC\fBshkey_t\fP\fP. \fBReturns:\fP
.RS 4
A \fC\fBshkey_t\fP\fP referencing a kvalue 
.RE
.PP

.SS "\fBshkey_t\fP* shkey_uniq (void)"
.PP
Create a unique \fC\fBshkey_t\fP\fP hashmap key reference. \fBReturns:\fP
.RS 4
A \fC\fBshkey_t\fP\fP containing a unique key value. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libshare from the source code.
