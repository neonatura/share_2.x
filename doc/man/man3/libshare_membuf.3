.TH "Dynamic Memory Buffers" 3 "9 Apr 2013" "Version 2.0.5" "libshare" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Dynamic Memory Buffers \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBshbuf_t\fP"
.br
.RI "\fIA memory buffer that utilizes that re-uses available memory to reduce OS overhead and dynamically grows to a user specific need. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBshbuf_t\fP \fBshbuf_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBshbuf_t\fP * \fBshbuf_init\fP (void)"
.br
.RI "\fIInitialize a memory buffer for use. \fP"
.ti -1c
.RI "void \fBshbuf_catstr\fP (\fBshbuf_t\fP *buf, char *data)"
.br
.RI "\fIInserts a string into a \fC\fBshbuf_t\fP\fP memory pool. \fP"
.ti -1c
.RI "void \fBshbuf_cat\fP (\fBshbuf_t\fP *buf, void *data, size_t data_len)"
.br
.RI "\fIInserts a binary data segment into a \fC\fBshbuf_t\fP\fP memory pool. \fP"
.ti -1c
.RI "size_t \fBshbuf_size\fP (\fBshbuf_t\fP *buf)"
.br
.RI "\fIThe current size of the data segement stored in the memory buffer. \fP"
.ti -1c
.RI "void \fBshbuf_clear\fP (\fBshbuf_t\fP *buf)"
.br
.RI "\fIClear the contents of a \fC\fBshbuf_t\fP\fP libshare memory buffer. \fP"
.ti -1c
.RI "void \fBshbuf_trim\fP (\fBshbuf_t\fP *buf, size_t len)"
.br
.RI "\fIReduce the data size of a memory buffer. \fP"
.ti -1c
.RI "void \fBshbuf_free\fP (\fBshbuf_t\fP **buf_p)"
.br
.RI "\fIFrees the resources utilizited by the memory buffer. \fP"
.ti -1c
.RI "int \fBshencode\fP (uint8_t *data, uint32_t *data_len, \fBshkey_t\fP *key)"
.br
.RI "\fIEncrypts byte array data of length len with key key using TEA. \fP"
.ti -1c
.RI "int \fBshdecode\fP (uint8_t *data, uint32_t *data_len, \fBshkey_t\fP *key)"
.br
.RI "\fIDecrypts byte array data of length len with key key using TEA. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void shbuf_cat (\fBshbuf_t\fP * buf, void * data, size_t data_len)"
.PP
Inserts a binary data segment into a \fC\fBshbuf_t\fP\fP memory pool. 
.SS "void shbuf_catstr (\fBshbuf_t\fP * buf, char * data)"
.PP
Inserts a string into a \fC\fBshbuf_t\fP\fP memory pool. 
.SS "void shbuf_clear (\fBshbuf_t\fP * buf)"
.PP
Clear the contents of a \fC\fBshbuf_t\fP\fP libshare memory buffer. 
.SS "void shbuf_free (\fBshbuf_t\fP ** buf_p)"
.PP
Frees the resources utilizited by the memory buffer. 
.SS "\fBshbuf_t\fP* shbuf_init (void)"
.PP
Initialize a memory buffer for use. \fBNote:\fP
.RS 4
A \fC\fBshbuf_t\fP\fP memory buffer handles automatic allocation of memory. 
.RE
.PP

.SS "size_t shbuf_size (\fBshbuf_t\fP * buf)"
.PP
The current size of the data segement stored in the memory buffer. 
.SS "void shbuf_trim (\fBshbuf_t\fP * buf, size_t len)"
.PP
Reduce the data size of a memory buffer. \fBParameters:\fP
.RS 4
\fIbuf\fP The memory buffer. 
.br
\fIlen\fP The size of bytes to reduce by. 
.RE
.PP
\fBNote:\fP
.RS 4
This removes data from the beginning of the data segment. 
.RE
.PP

.SS "int shdecode (uint8_t * data, uint32_t * data_len, \fBshkey_t\fP * key)"
.PP
Decrypts byte array data of length len with key key using TEA. \fBParameters:\fP
.RS 4
\fIdata\fP - pointer to 8 bit data array to be decrypted - SEE NOTES 
.br
\fIlen\fP - length of array 
.br
\fIkey\fP - Pointer to four integer array (16 bytes) holding TEA key 
.RE
.PP
\fBReturns:\fP
.RS 4
Fills \fBdata\fP with decrypted data and \fBlen\fP with the size of the new data 
.RE
.PP
\fBNote:\fP
.RS 4
Modifies data and len 
.RE
.PP
\fBBug\fP
.RS 4
Using magic numbers in encrypt and decrypt routines - use defines instead - Kyle 
.PP
If the 64 bit encoding functions aren't used outside this module, their prototypes should be in the code, not header - Simon 
.PP
Add sanity checking to input - Rob 
.PP
Require that input len is a multiple of 8 bytes - making a requirement we can't enforce or check is a recipe for corruption - Rob 
.RE
.PP

.SS "int shencode (uint8_t * data, uint32_t * data_len, \fBshkey_t\fP * key)"
.PP
Encrypts byte array data of length len with key key using TEA. \fBParameters:\fP
.RS 4
\fIdata\fP - pointer to 8 bit data array to be encrypted - SEE NOTES  - length of array 
.br
\fIkey\fP - Pointer to four integer array (16 bytes) holding TEA key 
.RE
.PP
\fBReturns:\fP
.RS 4
Fills \fCdata\fP with encrypted data and \fClen\fP with the size of the new data array 
.RE
.PP
\fBNote:\fP
.RS 4
data size must be equal to or larger than ((len + 7) / 8) * 8 + 8 TEA encrypts in 8 byte blocks, so it must include enough space to hold the entire data to pad out to an 8 byte boundary, plus another 8 bytes at the end to give the length to the decrypt algorithm. 
.PP
Make sure that data is at least len + 15 bytes in size! 
.PP
Modifies data and len 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libshare from the source code.
